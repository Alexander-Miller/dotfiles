#+STARTUP: overview
#+STARTUP: hideblocks

* Requirements

Load used libraries to somewhat reduce the amount of warnings.
#+BEGIN_SRC emacs-lisp
  (setq-local lexical-binding t)
  (require 'dash)
  (require 'f)
  (require 'cl-lib)
  (require 's)
  (require 'evil)
#+END_SRC

* Utility Functions
** Top Level
*** keybinds

~std::keybind~
#+BEGIN_SRC emacs-lisp
  (defmacro std::keybind (keymaps &rest keybinds)
    (declare (indent 1))
    (std::static-assert (= 0 (% (length keybinds) 2))
      "Uneven number of keybinds!")
    (unless (listp keymaps)
      (setq keymaps (list keymaps)))
    (-let [bind-forms nil]
      (while keybinds
        (-let [(key func . rest) keybinds]
          (-let [key (if (vectorp key) key `(kbd ,key))]
            (dolist (keymap keymaps)
              (push `(define-key ,keymap ,key ,func) bind-forms)))
          (setq keybinds rest)))
      `(progn ,@(nreverse bind-forms))))
#+END_SRC

~std::global-keybind~
#+BEGIN_SRC emacs-lisp
  (defmacro std::global-keybind (&rest binds)
    (std::static-assert (cl-evenp (length binds)))
    (-let [pairs nil]
      (while binds
        (push (cons (pop binds) (pop binds)) pairs))
      `(progn
         ,@(--map
            `(global-set-key (kbd ,(car it)) ,(cdr it))
            pairs))))
#+END_SRC

~std::evil-keybind~
#+BEGIN_SRC emacs-lisp
  (defmacro std::evil-keybind (states keymaps &rest keybinds)
    (declare (indent 2))
    (std::static-assert (= 0 (% (length keybinds) 2))
      "Uneven number of keybinds!")
    (unless (listp keymaps)
      (setf keymaps (list keymaps)))
    (unless (listp states)
      (setf states (list states)))
    (-let [bind-forms nil]
      (while keybinds
        (-let [(key func . rest) keybinds]
          (-let [key (if (vectorp key) key `(kbd ,key))]
            (dolist (keymap keymaps)
              (push `(evil-define-key ',states ,keymap ,key ,func) bind-forms)))
          (setq keybinds rest)))
      `(progn ,@(nreverse bind-forms))))
#+END_SRC

~std::leader-keybind~
#+BEGIN_SRC emacs-lisp
  (defmacro std::leader-keybind (&rest keybinds)
    (std::static-assert (= 0 (% (length keybinds) 2)) "Uneven number of keybinds!")
    `(spacemacs/set-leader-keys
       ,@keybinds))
#+END_SRC

~std::mode-leader-keybind~
#+BEGIN_SRC emacs-lisp
  (defmacro std::mode-leader-keybind (mode &rest keybinds)
    (declare (indent 1))
    (std::static-assert (= 0 (% (length keybinds) 2))
      "Uneven number of keybinds!")
    `(spacemacs/set-leader-keys-for-major-mode ,mode
       ,@keybinds))
#+END_SRC

*** std::after

#+BEGIN_SRC emacs-lisp
  (defmacro std::after (features &rest body)
    "Run BODY after loading FEATURE.
    Same as `with-eval-after-load', but there is no need to quote FEATURES."
    (declare (debug (sexp body)) (indent 1))
    (setf features (if (listp features) (nreverse features) (list features)))
    (let* ((module (pop features))
           (form `(with-eval-after-load
                      ,(if (stringp module)
                           module
                         `(quote ,module))
                    ,@body)))
      (while features
        (-let [module (pop features)]
          (setf form `(with-eval-after-load
                          ,(if (stringp module)
                               module
                             `(quote ,module))
                        ,form))))
      form))
#+END_SRC

*** std::static-assert

#+BEGIN_SRC emacs-lisp
  (defmacro std::static-assert (predicate &optional error-msg &rest error-args)
    (declare (indent 1))
    `(unless ,predicate
       (error (apply #'format
                     (or ,error-msg "Assertion Failure")
                     (list ,@error-args)))))
#+END_SRC

*** std::set-local

#+BEGIN_SRC emacs-lisp
  (defmacro std::set-local (&rest binds)
    (std::static-assert (cl-evenp (length binds)))
    (-let [pairs nil]
      (while binds
        (push (cons (pop binds) (pop binds)) pairs))
      `(progn
         ,@(--map
            `(setq-local ,(car it) ,(cdr it))
            (nreverse pairs)))))
#+END_SRC

*** std::fmt

#+BEGIN_SRC emacs-lisp
  (defmacro std::fmt (str) `(s-lex-format ,str))
#+END_SRC

*** std::idle

#+BEGIN_SRC emacs-lisp
  (defmacro std::idle (time repeat &rest body)
    (declare (indent 2))
    `(run-with-idle-timer ,time (eq ,repeat :repeat) (lambda () ,@body)))
#+END_SRC

*** std::notify

#+BEGIN_SRC emacs-lisp
  (cl-defmacro std::notify (title &key (txt "") (icon :NONE))
    (declare (indent 1))
    (-let [icon-arg
           (pcase icon
             (:NONE "--icon=emacs")
             ((pred stringp) (std::fmt "--icon=${icon}"))
             ((pred null)))]
      `(shell-command (format "notify-send '%s' '%s' %s" ,title ,txt ,icon-arg) nil nil)))
#+END_SRC

*** std::add-hooks

#+BEGIN_SRC emacs-lisp
  (defmacro std::add-hooks (cmd hooks)
    (declare (indent 1))
    `(progn
       ,@(--map `(add-hook ',it ,cmd)
               hooks)))
#+END_SRC

*** std::autoload

#+BEGIN_SRC emacs-lisp
  (defmacro std::autoload (&rest names)
    `(progn
       ,@(--map
          `(autoload ,it (std::fmt "${*SPACEMACSDIR*}/autoloads"))
          names)))
#+END_SRC

*** std::autoload-with

#+BEGIN_SRC emacs-lisp
  (defmacro std::autoload-with (name features &rest body)
    (declare (indent 1))
    (-let [advice-name (intern (std::fmt "std::autoload-${name}-advice"))]
      `(progn
         (defun ,advice-name (old-fun &rest args)
           (dolist (feature ',features)
             (advice-remove feature #',advice-name)
             ,@body)
           (apply old-fun args))
         (dolist (feature ',features)
           (advice-add feature :around #',advice-name)))))
#+END_SRC

** Autoloads
*** std::what-face

#+BEGIN_SRC emacs-lisp
  (std::autoload 'std::what-face)
  (std::global-keybind "C-x ö" #'std::what-face)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::what-face (point)
    "Reveal face at POINT."
    (interactive "d")
    (let ((face (or (get-char-property (point) 'read-face-name)
                    (get-char-property (point) 'face))))
      (if face (message "Face: %s" face) (message "No face at %d" point))))
#+END_SRC

*** std::packman-pkg-info

#+BEGIN_SRC emacs-lisp
  (std::autoload 'std::pacman-pkg-info)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::pacman-pkg-info ()
    (interactive)
    (let* ((completions (->> "pacman -Q"
                             (shell-command-to-string)
                             (s-trim)
                             (s-lines)
                             (--map (car (s-split " " it :no-nulls)))))
           (name (completing-read "Package: " completions)))
      (switch-to-buffer (get-buffer-create "*Package Info*"))
      (erase-buffer)
      (-> (std::fmt "pacman -Qi ${name}")
          (shell-command-to-string)
          (s-trim)
          (insert))
      (goto-char 0)
      (conf-mode)))
#+END_SRC

*** std::jira::new-log-entry

#+BEGIN_SRC emacs-lisp
  (std::autoload 'std::jira::new-log-entry)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::jira::new-log-entry ()
    (interactive)
    (let ((url (s-trim (current-kill 0)))
          (regex (rx bol (1+ any) "RETACC-" (1+ num) eol))
          (ticket-num))
      (unless (--any? (eq (car it) :table)
                      (org-context))
        (user-error "Not in a table."))
      (if (s-matches? regex url)
          (setq ticket-num (substring url (s-index-of "RETACC" url)))
        (user-error (format "Clipboard content '%s' is not a RETACC Jira Url."
                            (propertize url 'face 'font-lock-string-face))))
      (evil-normal-state)
      (insert (format "[[%s][%s]]" url ticket-num))
      (org-ctrl-c-ctrl-c)))
#+END_SRC

*** std::org-files

#+BEGIN_SRC emacs-lisp
  (std::autoload 'std::org-files)
  (std::leader-keybind "aof" #'std::org-files)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (eval-when-compile (require 'helm))
  (defun std::org-files ()
    (interactive)
    (helm :prompt "Org File: "
          :buffer "*helm org files*"
          :sources (helm-build-sync-source "Org Files"
                     :candidates (--map (cons (f-filename it) it) (f-files org-directory))
                     :action #'find-file-existing
                     :filtered-candidate-transformer #'helm-fuzzy-highlight-matches)))
#+END_SRC

*** std::fold-defun

#+BEGIN_SRC emacs-lisp
  (std::autoload 'std::fold-defun)
  (define-key evil-normal-state-map (kbd "züf") #'std::fold-defun)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::fold-defun ()
    (interactive)
    (save-excursion
      (end-of-line)
      (beginning-of-defun)
      (end-of-line)
      (evil-close-fold)))
#+END_SRC

*** std::what-major-mode

#+BEGIN_SRC emacs-lisp
  (std::autoload 'std::what-major-mode)
  (std::global-keybind "C-x ä" #'std::what-major-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::what-major-mode ()
    "Reveal current major mode."
    (interactive)
    (message "%s" major-mode))
#+END_SRC

*** std::edit-org-user-config

#+BEGIN_SRC emacs-lisp
  (std::autoload 'std::edit-org-user-config)
  (std::leader-keybind "feo" #'std::edit-org-user-config)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::edit-org-user-config ()
    "Edit the org user config file, in the current window."
    (interactive)
    (find-file-existing (concat *SPACEMACSDIR* "/user-config.org")))
#+END_SRC

*** std::fill-dwim

#+BEGIN_SRC emacs-lisp
  (std::autoload 'std::fill-dwim)
  (std::global-keybind "M-q" #'std::fill-dwim)
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::fill-dwim ()
    (interactive)
    (cond
     ((region-active-p)
      (call-interactively #'fill-region))
     ((eq major-mode 'org-mode)
      (call-interactively #'org-fill-paragraph))
     (t
      (call-interactively #'fill-paragraph))))
#+END_SRC

* Config tangle & compilation

To save on startup time the config file is only loaded on boot. Tangling and compilation is
instead run as part of ~kill-emacs-hook~, relieving the need to load all of org and tangle the
config before emacs may be used.

The function to tangle and recompile the config, running only if the org file was recently modified.
#+BEGIN_SRC emacs-lisp
  (autoload #'org-babel-tangle-file "ob-tangle")

  (defun std::config-tangle-and-recompile ()
    (interactive)
    (let* ((byte-compile-warnings '(not unresolved free-vars))
           (dir       *SPACEMACSDIR*)
           (el-file   (std::fmt "${dir}/user-config.el"))
           (org-file  (file-chase-links (concat dir "/user-config.org")))
           (autoloads (std::fmt "${dir}/autoloads.el")))
      (when (or (called-interactively-p 'interactive)
                (not (file-exists-p el-file))
                (not (file-exists-p autoloads))
                (file-newer-than-file-p org-file el-file)
                (file-newer-than-file-p org-file autoloads))
        (condition-case e
            (progn
              (org-babel-tangle-file org-file el-file "emacs-lisp")
              (byte-recompile-file el-file t 0 nil)
              (byte-recompile-file autoloads t 0 nil))
          (error (shell-command (std::fmt "notify-send 'ERROR' '${e}'")))))))
#+END_SRC

Advice to insert reload before spacemacs' layer syncing.
#+BEGIN_SRC emacs-lisp
  (defun std::layer-sync-config-tangle-advice (&rest _)
    (std::config-tangle-and-recompile))
#+END_SRC

Insert retangle before both quitting emacs and reloading the config.
#+BEGIN_SRC emacs-lisp
  (add-hook 'kill-emacs-hook #'std::config-tangle-and-recompile)
  (advice-add #'dotspacemacs/sync-configuration-layers :after #'std::layer-sync-config-tangle-advice)
#+END_SRC

* Layer configurations
** Evil
*** Fitting cursor state colors

#+BEGIN_SRC emacs-lisp
  (setq
   evil-normal-state-cursor   '("#ab3737" box)
   evil-insert-state-cursor   '("#33aa33" bar)
   evil-visual-state-cursor   '("#a374a8" box)
   evil-motion-state-cursor   '("#c97449" box)
   evil-operator-state-cursor '("#00688b" (hbar . 5))
   evil-emacs-state-cursor    '("#339999" bar)
   evil-resize-state-cursor   '("#ffdb1a" box))

  (setq spacemacs-evil-cursors
        '(("normal"       "#ab3737"         box)
          ("insert"       "#33aa33"         (bar . 2))
          ("emacs"        "#339999"         box)
          ("hybrid"       "#339999"         (bar . 2))
          ("replace"      "#993333"         (hbar . 2))
          ("evilified"    "LightGoldenrod3" box)
          ("visual"       "gray"            (hbar . 2))
          ("motion"       "plum3"           box)
          ("lisp"         "HotPink1"        box)
          ("iedit"        "firebrick1"      box)
          ("iedit-insert" "firebrick1"      (bar . 2))))
#+END_SRC

*** kj key-chord

#+BEGIN_SRC emacs-lisp
  (setq-default evil-escape-key-sequence "kj")
#+END_SRC

*** Custom text objects

#+BEGIN_SRC emacs-lisp
  (evil-define-text-object std::evil::defun-object (count &optional beg end type)
    "Evil defun text object."
    (let ((start) (finish))
      (mark-defun)
      (setq start  (region-beginning)
            finish (region-end))
      (deactivate-mark)
      (evil-range start finish type )))

  (define-key evil-operator-state-map "üf" #'std::evil::defun-object)
  #+END_SRC

*** Evil Goggles
**** Settings

#+BEGIN_SRC emacs-lisp
  (evil-goggles-mode t)
  (setq evil-goggles-duration                     0.15
        evil-goggles-pulse                        nil
        evil-goggles-enable-change                t
        evil-goggles-enable-delete                t
        evil-goggles-enable-indent                t
        evil-goggles-enable-yank                  t
        evil-goggles-enable-join                  t
        evil-goggles-enable-fill-and-move         t
        evil-goggles-enable-paste                 t
        evil-goggles-enable-shift                 t
        evil-goggles-enable-surround              t
        evil-goggles-enable-commentary            t
        evil-goggles-enable-nerd-commenter        t
        evil-goggles-enable-replace-with-register t
        evil-goggles-enable-set-marker            t
        evil-goggles-enable-undo                  t
        evil-goggles-enable-redo                  t)
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (setq evil-move-beyond-eol t
        evil-want-fine-undo  t)

  (std::after evil-escape
    (add-to-list 'evil-escape-excluded-major-modes 'org-agenda-mode)
    (add-to-list 'evil-escape-excluded-major-modes 'dired-mode))

  (std::after ediff
    (evil-collection-init 'ediff))

  (evil-lion-mode)
#+END_SRC

*** Keybinds

Quicker movement with J/K
#+BEGIN_SRC emacs-lisp
  (evil-define-motion std::evil::forward-five-lines ()
    "Move the cursor 5 lines down."
    :type line
    (let (line-move-visual)
      (evil-line-move 5)))

  (evil-define-motion std::evil::backward-five-lines ()
    "Move the cursor 5 lines up."
    :type line
    (let (line-move-visual)
      (evil-line-move -5)))

  (std::keybind (evil-normal-state-map evil-visual-state-map evil-motion-state-map)
    "J" #'std::evil::forward-five-lines
    "K" #'std::evil::backward-five-lines)
#+END_SRC

Emacs-like line start/end jump
#+BEGIN_SRC emacs-lisp
  (std::keybind (evil-motion-state-map evil-normal-state-map evil-visual-state-map evil-insert-state-map)
    "C-e" #'evil-end-of-visual-line
    "C-a" #'evil-beginning-of-visual-line)
#+END_SRC

Splitting and joining lines
#+BEGIN_SRC emacs-lisp
  (std::keybind evil-normal-state-map
    "C-j" #'newline-and-indent
    "M-j" #'evil-join)
#+END_SRC

Find definition
#+BEGIN_SRC emacs-lisp
  (std::keybind (evil-insert-state-map evil-normal-state-map evil-motion-state-map evil-evilified-state-map)
    "M-." #'xref-find-definitions)
#+END_SRC

Same comment keybind as in eclipse
#+BEGIN_SRC emacs-lisp
  (std::global-keybind "C-7" #'evilnc-comment-operator)
#+END_SRC

** Elisp
*** Settings

Completion backends
#+BEGIN_SRC emacs-lisp
  (std::after company
    (setq company-backends-emacs-lisp-mode
          '((company-capf company-files :with company-yasnippet)
            (company-dabbrev-code company-dabbrev))))
#+END_SRC

Syntax highlighting for symbols and function symbols
#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords
   'emacs-lisp-mode
   `((,(rx (group-n
            1
            (not (any "#"))
            "'"
            symbol-start
            (1+ (or (syntax word)
                    (syntax symbol)))
            symbol-end))
      1 font-lock-type-face)
     (,(rx (group-n
            1
            "#'")
           (group-n
            2
            symbol-start
            (1+ (or (syntax word)
                    (syntax symbol)))
            symbol-end))
      (1 font-lock-constant-face)
      (2 font-lock-function-name-face)))
   'append)
#+END_SRC

*** Functions

The elisp repl window refuses to be controlled by shackle, so we'll
do it manually.

~std::elisp::ielm~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::elisp::ielm ()
    "Interactively evaluate Emacs Lisp expressions.
  Switches to the buffer `*ielm*', or creates it if it does not exist.
  See `inferior-emacs-lisp-mode' for details."
    (interactive)
    (require 'ielm)
    (let (old-point)
      (unless (comint-check-proc "*ielm*")
        (with-current-buffer (get-buffer-create "*ielm*")
          (unless (zerop (buffer-size)) (setq old-point (point)))
          (inferior-emacs-lisp-mode)))
      (pop-to-buffer "*ielm*")
      (when old-point (push-mark old-point))))
#+END_SRC

~std::elisp::fold-all-top-level-forms~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::elisp::fold-all-top-level-forms ()
    (interactive)
    (save-excursion
      (save-match-data
        (evil-with-state 'insert
          (goto-char (point-min))
          (while (search-forward-regexp (rx bol "(") nil t)
            (evil-close-fold))))))
#+END_SRC

Autoloads
#+BEGIN_SRC emacs-lisp
  (std::autoload #'std::elisp::ielm #'std::elisp::fold-all-top-level-forms)
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::mode-leader-keybind 'emacs-lisp-mode
    "'" #'std::elisp::ielm
    "C" #'std::elisp::fold-all-top-level-forms)
#+END_SRC

** Auto Completion
*** Global Activation

#+BEGIN_SRC emacs-lisp
  (std::after company
    (global-company-mode t))
#+END_SRC

After lazy-loading company may not have been set up everywhere, at least the scratch buffer will lack
a proper backends value, so we just iterate our way through every buffer and set company-bakends to
something appropriate for the current major-mode whenever the backends are nil.
#+BEGIN_SRC emacs-lisp
  (std::after company
    (dolist (buf (buffer-list))
      (unless (eq ?\ (aref (buffer-name buf) 0))
        (with-current-buffer buf
          (when (null company-backends)
            (-let [backends-var (intern (std::fmt "company-backends-${major-mode}"))]
              (setq-local company-backends
                          (if (boundp backends-var)
                              (symbol-value backends-var)
                            '((company-capf company-files :with company-yasnippet)
                              (company-dabbrev company-dabbrev-code company-keywords))))))))))
#+END_SRC

*** Settings
**** Company Settings

#+BEGIN_SRC emacs-lisp
  (std::after company
    (setq
     company-abort-manual-when-too-short t
     company-auto-complete               nil
     company-async-timeout               10
     company-dabbrev-code-ignore-case    nil
     company-dabbrev-downcase            nil
     company-dabbrev-ignore-case         nil
     company-etags-ignore-case           nil
     company-idle-delay                  10
     company-minimum-prefix-length       2
     company-require-match               nil
     company-selection-wrap-around       t
     company-show-numbers                t
     company-tooltip-flip-when-above     nil))
#+END_SRC

**** Tooltip

The tooltip will look vastly better if we set a minimum width and properly align annotations.
#+BEGIN_SRC emacs-lisp
  (std::after company
    (setq
     company-tooltip-minimum-width              70
     company-tooltip-align-annotations          t
     company-tooltip-margin                     2))
#+END_SRC

*** Backend Priority

The completions provided by combined backends should be sorted, so as to avoid
interspersing semantic completion candidates with dumb code-dabbrevs
#+BEGIN_SRC emacs-lisp
  (std::after company
    (defconst std::company::backend-priorities
      '((company-fish-shell   . 10)
        (company-shell        . 11)
        (company-shell-env    . 12)
        (company-anaconda     . 10)
        (company-capf         . 50)
        (company-yasnippet    . 60)
        (company-keywords     . 70)
        (company-files        . 80)
        (company-dabbrev-code . 90)
        (company-dabbrev      . 100))
      "Alist of backends' priorities.  Smaller number means higher priority.")

    (define-inline std::company::priority-of-backend (backend)
      "Will retrieve priority of BACKEND.
  Defauts to 999 if BACKEND is nul or has no priority defined."
      (inline-letevals (backend)
        (inline-quote
         (let ((pr (cdr (assoc ,backend std::company::backend-priorities))))
           (if (null pr) 999 pr)))))

    (defun std::company::priority-compare (c1 c2)
      "Compares the priorities of C1 & C2."
      (let* ((b1   (get-text-property 0 'company-backend c1))
             (b2   (get-text-property 0 'company-backend c2))
             (p1   (std::company::priority-of-backend b1))
             (p2   (std::company::priority-of-backend b2))
             (diff (- p1 p2)))
        (< diff 0)))

    (defun std::company::sort-by-backend-priority (candidates)
      "Will sort completion CANDIDATES according to their priorities."
      (sort (delete-dups candidates) #'std::company::priority-compare)))
#+END_SRC

The priority sorting is only used in major modes which use combined backends
#+BEGIN_SRC emacs-lisp
  (defun std::company::use-completions-priority-sorting ()
    (setq-local company-transformers '(company-flx-transformer company-sort-by-occurrence std::company::sort-by-backend-priority)))

  (std::add-hooks #'std::company::use-completions-priority-sorting
    (rust-mode-hook fish-mode-hook python-mode-hook))
#+END_SRC

*** Quickhelp

Quickhelp makes company's modemaps unreliable, so we rewrite the underlying keymap while company is active
#+BEGIN_SRC emacs-lisp
  (std::after company-quickhelp

    (defun std::company::off (arg)
      "Use default keys when company is not active. ARG is ignored."
      (std::keybind (evil-normal-state-map evil-insert-state-map)
        "C-j" #'newline-and-indent
        "C-k" #'kill-line)
      (std::keybind evil-insert-state-map
        "C-l" #'yas-expand))

    (defun std::company::on (arg)
      "Use company's keys when company is active.
  Necessary due to company-quickhelp using global key maps.
  ARG is ignored."
      (std::keybind (evil-normal-state-map evil-insert-state-map)
        "C-j" #'company-select-next
        "C-k" #'company-select-previous)
      (std::keybind evil-insert-state-map
        "C-l" #'company-quickhelp-manual-begin))

    (add-hook 'company-completion-started-hook   #'std::company::on)
    (add-hook 'company-completion-finished-hook  #'std::company::off)
    (add-hook 'company-completion-cancelled-hook #'std::company::off)

    (define-key company-active-map (kbd "C-l") #'company-quickhelp-manual-begin))
#+END_SRC

*** Flx

#+BEGIN_SRC emacs-lisp
  (std::after company
    (company-flx-mode t)
    (setf company-flx-limit 300))
#+END_SRC

*** Bindings

#+BEGIN_SRC emacs-lisp
  (std::global-keybind
   "C-SPC" #'company-complete
   "C-@"   #'company-complete)
#+END_SRC

** Window Management
*** Shackle

Replace popwin
#+BEGIN_SRC emacs-lisp
  (shackle-mode t)

  (setq helm-display-function #'pop-to-buffer)

  (setq shackle-rules
        '(("*helm-ag*"              :select t   :align right :size 0.5)
          ("*helm semantic/imenu*"  :select t   :align right :size 0.4)
          ("*helm org inbuffer*"    :select t   :align right :size 0.4)
          (magit-popup-mode         :select t   :align right :size 0.4)
          (flycheck-error-list-mode :select nil :align below :size 0.25)
          (compilation-mode         :select nil :align below :size 0.25)
          (messages-buffer-mode     :select t   :align below :size 0.25)
          (inferior-emacs-lisp-mode :select t   :align below :size 0.25)
          (ert-results-mode         :select t   :align below :size 0.5)
          (calendar-mode            :select t   :align below :size 0.25)
          (racer-help-mode          :select t   :align right :size 0.5)
          (help-mode                :select t   :align right :size 0.5)
          (helpful-mode             :select t   :align right :size 0.5)
          (" *Deletions*"           :select t   :align below :size 0.25)
          (" *Marked Files*"        :select t   :align below :size 0.25)
          ("*Org Select*"           :select t   :align below :size 0.33)
          ("*Org Note*"             :select t   :align below :size 0.33)
          ("*Org Links*"            :select t   :align below :size 0.2)
          (" *Org todo*"            :select t   :align below :size 0.2)
          ("*Man.*"                 :select t   :align below :size 0.5  :regexp t)
          ("*helm.*"                :select t   :align below :size 0.33 :regexp t)
          ("*Org Src.*"             :select t   :align right :size 0.5  :regexp t)))
#+END_SRC

*** Purposes
**** Shackle Integration

#+BEGIN_SRC emacs-lisp
  (std::after window-purpose
    (defun maybe-display-shackle (buffer alist)
      (and (shackle-display-buffer-condition buffer alist)
           (shackle-display-buffer-action buffer alist)))

    (setq purpose-action-sequences
          '((switch-to-buffer
             . (purpose-display-reuse-window-buffer
                purpose-display-reuse-window-purpose
                maybe-display-shackle
                purpose-display-maybe-same-window
                purpose-display-maybe-other-window
                purpose-display-maybe-other-frame
                purpose-display-maybe-pop-up-window
                purpose-display-maybe-pop-up-frame))

            (prefer-same-window
             . (purpose-display-maybe-same-window
                maybe-display-shackle
                purpose-display-reuse-window-buffer
                purpose-display-reuse-window-purpose
                purpose-display-maybe-other-window
                purpose-display-maybe-other-frame
                purpose-display-maybe-pop-up-window
                purpose-display-maybe-pop-up-frame))

            (force-same-window
             . (purpose-display-maybe-same-window
                maybe-display-shackle))

            (prefer-other-window

             . (purpose-display-reuse-window-buffer
                purpose-display-reuse-window-purpose
                maybe-display-shackle
                purpose-display-maybe-other-window
                purpose-display-maybe-pop-up-window
                purpose-display-maybe-other-frame
                purpose-display-maybe-pop-up-frame
                purpose-display-maybe-same-window))

            (prefer-other-frame
             . (purpose-display-reuse-window-buffer-other-frame
                purpose-display-reuse-window-purpose-other-frame
                maybe-display-shackle
                purpose-display-maybe-other-frame
                purpose-display-maybe-pop-up-frame
                purpose-display-maybe-other-window
                purpose-display-maybe-pop-up-window
                purpose-display-reuse-window-buffer
                purpose-display-reuse-window-purpose
                purpose-display-maybe-same-window)))))
#+END_SRC

**** Custom Purposes

#+BEGIN_SRC emacs-lisp
  (std::after window-purpose
    (setq purpose-user-mode-purposes
          '((flycheck-error-list-mode . bottom)
            (messages-buffer-mode     . bottom)
            (compilation-mode         . bottom)
            (inferior-emacs-lisp-mode . bottom)))

    (purpose-compile-user-configuration))
#+END_SRC

**** Shackle-friendly Functions

~std::pop-to-messages-buffer~
#+BEGIN_SRC emacs-lisp
  (defun std::pop-to-messages-buffer (&optional arg)
    "Same as the spacemacs builtin, but uses `pop-to-buffer'.
    This ensures that shackle's (or purpose's) rules apply to the new window."
    (interactive "P")
    (-let [buf (messages-buffer)]
      (--if-let (get-buffer-window buf)
          (delete-window it)
        (with-current-buffer (messages-buffer)
          (goto-char (point-max))
          (if arg
              (switch-to-buffer-other-window (current-buffer))
            (pop-to-buffer (current-buffer)))))))

  (std::leader-keybind "bm" #'std::pop-to-messages-buffer)
#+END_SRC

*** Eyebrowse

Switch desktops via SPC + num
#+BEGIN_SRC emacs-lisp
  (eyebrowse-mode t)
  (std::leader-keybind
   "1" #'eyebrowse-switch-to-window-config-1
   "2" #'eyebrowse-switch-to-window-config-2
   "3" #'eyebrowse-switch-to-window-config-3
   "4" #'eyebrowse-switch-to-window-config-4
   "5" #'eyebrowse-switch-to-window-config-5
   "6" #'eyebrowse-switch-to-window-config-6
   "7" #'eyebrowse-switch-to-window-config-7
   "8" #'eyebrowse-switch-to-window-config-8
   "9" #'eyebrowse-switch-to-window-config-9
   "0" #'eyebrowse-switch-to-window-config-0)
#+END_SRC

*** Winum
**** Settings

#+BEGIN_SRC emacs-lisp
  (setq winum-scope 'frame-local)
  (winum-mode)
#+END_SRC

**** Keybinds

Window #0 is reverved for treemacs.
#+BEGIN_SRC emacs-lisp
  (std::keybind winum-keymap
    "M-1" #'winum-select-window-1
    "M-2" #'winum-select-window-2
    "M-3" #'winum-select-window-3
    "M-4" #'winum-select-window-4
    "M-5" #'winum-select-window-5
    "M-6" #'winum-select-window-6
    "M-7" #'winum-select-window-7
    "M-8" #'winum-select-window-8
    "M-9" #'winum-select-window-9)
#+END_SRC

*** Framey
**** Settings

#+BEGIN_SRC emacs-lisp
  (std::after helm (framey-mode))

  (std::after framey
    (setq framey-show-modeline nil))

  (std::autoload-with "Framey"
    (helpful-at-point)
    (require 'framey))
#+END_SRC

*** General Keybinds

Killing a buffer alongside its window
#+BEGIN_SRC emacs-lisp
  (std::leader-keybind "b C-d" #'kill-buffer-and-window)
#+END_SRC

TODO
Quitting with *q*
#+BEGIN_SRC emacs-lisp
  (std::evil-keybind normal messages-buffer-mode-map
    "q" #'quit-window)

  (std::after flycheck
    (std::keybind flycheck-error-list-mode-map
      "q" #'kill-buffer-and-window))

  (std::after Man-mode
    (std::keybind Man-mode-map
      "q" #'kill-buffer-and-window))

  (std::after helpful
    (std::evil-keybind (normal motion) helpful-mode-map
      "q" #'framey-quit-window))
#+END_SRC

** Org
*** Functions

~std::org::mode-hook~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::org::mode-hook ()
    (smartparens-mode t)
    ;; disbaling with git-gutter doesn't work since text-mode's
    ;; hook is called as well
    (std::idle 0.1 :no-repeat (git-gutter-mode -1)))
#+END_SRC

~org-switch-to-buffer-other-window~
Org thinks it's a good idea to disable ~display-buffer-alist~ when displaying its buffers. I don't.
I want my buffers' display behaviour to be handled by shackle. All of them. No exceptions.
#+BEGIN_SRC emacs-lisp
  (std::after org
    (defun org-switch-to-buffer-other-window (&rest args)
      "Same as the original, but lacking the wrapping call to `org-no-popups'"
      (apply 'switch-to-buffer-other-window args)))
#+END_SRC

~std::org::capture-std-target~
#+BEGIN_SRC  emacs-lisp
  (std::after org
    (defun std::org::capture-std-target ()
      `(file+headline
        ,(concat org-directory "Capture.org")
        ,(if (s-equals? (system-name) "a-laptop")
             "Ideen"
           "Postfach"))))
#+END_SRC

~std::org::table-recalc~
#+BEGIN_SRC emacs-lisp
  (std::after org
    (defun std::org::table-recalc ()
      "Reverse the prefix arg bevaviour of `org-table-recalculate', such that
  by default the entire table is recalculated, while with a prefix arg recalculates
  only the current cell."
      (interactive)
      (setq current-prefix-arg (not current-prefix-arg))
      (call-interactively #'org-table-recalculate)))
#+END_SRC

~std::org::table-switch-left~
~std::org::table-switch-right~
#+BEGIN_SRC emacs-lisp
  (std::after org
    (defun std::org::table-switch-right ()
      "Switch content of current table cell with the cell to the right."
      (interactive)
      (when (org-at-table-p)
        (std::org::table-switch (org-table-current-line) (1+ (org-table-current-column)))))

    (defun std::org::table-switch-left ()
      "Switch content of current table cell with the cell to the left."
      (interactive)
      (when (org-at-table-p)
        (std::org::table-switch (org-table-current-line) (1- (org-table-current-column)))))

    (defun std::org::table-switch (x2 y2)
      (let* ((p  (point))
             (x1 (org-table-current-line))
             (y1 (org-table-current-column))
             (t1 (org-table-get x1 y1))
             (t2 (org-table-get x2 y2)))
        (org-table-put x1 y1 t2)
        (org-table-put x2 y2 t1 t)
        (goto-char p))))
#+END_SRC

~std::org::plot-table~
#+BEGIN_SRC emacs-lisp
  (std::after org
    (defun std::org::plot-table ()
      "Plot table at point and clear image cache.
  The cache clearing will update tables visible as inline images."
      (interactive)
      (save-excursion
        (org-plot/gnuplot)
        (clear-image-cache))))
#+END_SRC

Autoloads
#+BEGIN_SRC emacs-lisp
  (add-hook 'org-mode-hook #'std::org::mode-hook)
  (std::autoload #'std::org::mode-hook)
#+END_SRC

*** Settings
**** Prerequisites

#+BEGIN_SRC emacs-lisp
  (setq-default org-directory          "~/Documents/Org/"
                org-default-notes-file (concat org-directory "Capture.org"))
#+END_SRC

**** Startup

#+BEGIN_SRC emacs-lisp
  (std::after org
    (setq org-startup-folded             t
          org-startup-indented           t
          org-startup-align-all-tables   t
          org-startup-with-inline-images nil))
#+END_SRC

**** Additional modules

#+BEGIN_SRC emacs-lisp
  (std::after org
    (add-to-list 'org-modules 'org-habit)
    (require 'org-habit))
#+END_SRC

**** Better looking TODO keywords

#+BEGIN_SRC emacs-lisp
  (std::after org
    (setq-default org-todo-keywords '((sequence "»TODO«" "|" "»DONE«"))))
#+END_SRC

**** No "special" behaviour.

#+BEGIN_SRC emacs-lisp
  (std::after org
    (setq
     org-special-ctrl-a         nil
     org-special-ctrl-k         nil
     org-special-ctrl-o         nil
     org-special-ctrl-a/e       nil
     org-ctrl-k-protect-subtree nil))
#+END_SRC

**** Agenda

#+BEGIN_SRC emacs-lisp
  (std::after org-agenda

    (require 'german-holidays)

    (add-to-list 'org-agenda-files (concat org-directory "NT.org"))

    (when (string= "a-laptop" (system-name))
      (add-to-list 'org-agenda-files (concat org-directory "Privat.org")))

    (setq
     calendar-holidays                                holiday-german-BW-holidays
     org-agenda-include-diary                         nil
     org-agenda-skip-scheduled-if-deadline-is-shown   t
     org-agenda-skip-scheduled-if-done                nil
     org-agenda-skip-scheduled-delay-if-deadline      nil
     org-agenda-skip-additional-timestamps-same-entry nil
     org-agenda-skip-deadline-prewarning-if-scheduled t
     org-agenda-span                                 14
     org-agenda-inhibit-startup                      t
     org-agenda-window-frame-fractions               '(0.7 . 0.7)
     org-agenda-window-setup                         'only-window
     org-deadline-warning-days                       7
     org-extend-today-until                          2))
#+END_SRC

**** Habits

#+BEGIN_SRC emacs-lisp
  (std::after org-habit
    (setq org-habit-graph-column               70
          org-habit-preceding-days             21
          org-habit-following-days             7
          org-habit-show-habits-only-for-today nil))
#+END_SRC

**** Bullets

Use only one bullet for headings (original = "◉" "○" "✸" "✿")
#+BEGIN_SRC emacs-lisp
   (std::after org
     (setq-default org-bullets-bullet-list '("✿")))
#+END_SRC

Also use ascii bullets for simple lists
#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords
   'org-mode
   '(("^ +\\([-*]\\) " (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC

**** Capture

#+BEGIN_SRC emacs-lisp
  (std::after org
    (setq
     org-capture-templates
     `(("t" "Idee/Todo" entry
        ,(std::org::capture-std-target)
        "** [TODO] %?\n %U"))))
#+END_SRC

**** Tables

#+BEGIN_SRC emacs-lisp
  (std::after org
    (setq org-table-auto-blank-field        nil
          org-table-use-standard-references t))
#+END_SRC

**** Source Blocks & Tangling

#+BEGIN_SRC emacs-lisp
  (std::after org
    (setq org-edit-src-auto-save-idle-delay           0
          org-edit-src-turn-on-auto-save              nil
          org-src-fontify-natively                    t
          org-strc-preserve-indentation               nil
          org-edit-src-content-indentation            2
          org-src-ask-before-returning-to-edit-buffer nil
          org-src-window-setup                        'other-window))
#+END_SRC

**** Other/Sort later

#+BEGIN_SRC emacs-lisp
  (std::after org

    (setf (nthcdr 4 org-emphasis-regexp-components) '(3))

    (setq
     calendar-date-style                     'european
     org-tags-column                         85
     org-closed-keep-when-no-todo            nil
     org-use-fast-todo-selection             t
     org-enforce-todo-dependencies           t
     org-enforce-todo-checkbox-dependencies  t
     org-export-use-babel                    t
     org-list-demote-modify-bullet           '(("+" . "-") ("-" . "+") ("*" . "+"))
     org-list-indent-offset                  1
     org-log-done                            'time
     org-ellipsis                            " "
     org-footnote-section                    "Footnotes"
     org-log-into-drawer                     t
     org-table-use-standard-references       nil
     org-cycle-emulate-tab                   t
     org-cycle-global-at-bob                 nil
     org-M-RET-may-split-line                nil
     org-fontify-whole-heading-line          nil
     org-catch-invisible-edits               'show
     org-refile-targets                      '((nil . (:maxlevel . 10)))
     org-footnote-auto-adjust                t
     org-file-apps                           '((auto-mode . emacs)
                                               ("\\.mm\\'" . default)
                                               ("\\.eml\\'" . "thunderbird \"%s\"")
                                               ("\\.x?html?\\'" . default)
                                               ("\\.pdf\\'" . default))
     org-show-context-detail                 '((agenda . local)
                                               (bookmark-jump . lineage)
                                               (isearch . lineage)
                                               (default . ancestors)))

    (setq-default
     org-display-custom-times nil
     ;; org-time-stamp-formats   '("<%Y-%m-%d %a>" . "<%Y-%m-%d %a %H:%M>")
     ))
  ;;  org-catch-invisible-edits      'show
  ;;  org-fontify-whole-heading-line nil
  ;;  ;; org-hide-block-overlays
  ;;  org-hide-emphasis-markers      t
  ;;  org-list-indent-offset         1
  ;;  org-list-allow-alphabetical    nil
#+END_SRC

*** Babel Languages

#+BEGIN_SRC emacs-lisp
  (defmacro std::org::use-babel-use-languages (&rest langs)
    (-let [forms nil]
      (dolist (lang langs)
        (push
         `(progn
            (autoload ',(intern (concat "org-babel-execute:" lang)) ,(concat "ob-" lang))
            (autoload ',(intern (concat "org-babel-expand-body:" lang)) ,(concat "ob-" lang)))
         forms))
      `(progn ,@forms)))

  (std::after org
    (std::org::use-babel-use-languages "emacs-lisp" "sh" "python" "shell" "gnuplot"))
#+END_SRC

*** Font Locking

A small bit of custom font locking for '==>'
#+BEGIN_SRC emacs-lisp
  (defface std::result-face
    `((t (:foreground "#886688" :bold t)))
    "Face for '==>'.")

    (font-lock-add-keywords
     'org-mode
     '(("==>" . 'std::result-face)))
#+END_SRC

*** Keybinds
**** Showing content

#+BEGIN_SRC emacs-lisp
  (std::after org
    (std::mode-leader-keybind 'org-mode
      "rr" #'org-reveal
      "rb" #'outline-show-branches
      "rc" #'outline-show-children
      "ra" #'outline-show-all))
#+END_SRC

**** Headline Navigation

#+BEGIN_SRC emacs-lisp
  (std::after org
    (std::mode-leader-keybind 'org-mode
      "u"   #'outline-up-heading
      "M-u" #'helm-org-parent-headings
      "j"   #'org-next-visible-heading
      "k"   #'org-previous-visible-heading
      "C-j" #'org-forward-heading-same-level
      "C-k" #'org-backward-heading-same-level))
#+END_SRC

**** Scheduling

#+BEGIN_SRC emacs-lisp
  (std::after org
    (std::mode-leader-keybind 'org-mode
      "s"  nil
      "ss" #'org-schedule
      "st" #'org-time-stamp
      "sd" #'org-deadline))
#+END_SRC

**** (Sub)Tree

#+BEGIN_SRC emacs-lisp
  (std::after org
    (std::mode-leader-keybind 'org-mode
      "wi" #'org-tree-to-indirect-buffer
      "wm" #'org-mark-subtree
      "wd" #'org-cut-subtree
      "wy" #'org-copy-subtree
      "wY" #'org-clone-subtree-with-time-shift
      "wp" #'org-paste-subtree
      "wr" #'org-refile))
#+END_SRC

**** Structure Editing

#+BEGIN_SRC emacs-lisp
  (std::after org
    (dolist (mode '(normal insert))
      (evil-define-key mode org-mode-map
        (kbd "M-RET") #'org-meta-return
        (kbd "M-h")   #'org-metaleft
        (kbd "M-l")   #'org-metaright
        (kbd "M-j")   #'org-metadown
        (kbd "M-k")   #'org-metaup
        (kbd "M-H")   #'org-shiftmetaleft
        (kbd "M-L")   #'org-shiftmetaright
        (kbd "M-J")   #'org-shiftmetadown
        (kbd "M-K")   #'org-shiftmetaup
        (kbd "M-t")   #'org-insert-todo-heading-respect-content)))
#+END_SRC

**** Sparse Trees

#+BEGIN_SRC emacs-lisp
  (std::after org
    (std::mode-leader-keybind 'org-mode
      "7"   #'org-sparse-tree
      "8"   #'org-occur
      "M-j" #'next-error
      "M-k" #'previous-error))
#+END_SRC

**** Narrowing

#+BEGIN_SRC emacs-lisp
  (std::after org
    (std::mode-leader-keybind 'org-mode
      "n"  nil
      "nb" #'org-narrow-to-block
      "ne" #'org-narrow-to-element
      "ns" #'org-narrow-to-subtree
      "nw" #'widen))
#+END_SRC

**** Insert Commands

#+BEGIN_SRC emacs-lisp
  (std::after org
    (std::mode-leader-keybind 'org-mode
      "if" #'org-footnote-new
      "il" #'org-insert-link
      "in" #'org-add-note
      "id" #'org-insert-drawer
      "ii" #'org-time-stamp-inactive
      "iI" #'org-time-stamp))
#+END_SRC

**** Tables

#+BEGIN_SRC emacs-lisp
  (std::after org
    ;; TODO: rebind clock
    (spacemacs/set-leader-keys-for-major-mode 'org-mode "q" nil)

    (std::mode-leader-keybind 'org-mode
      "t"   nil
      "tb"  #'org-table-blank-field
      "ty"  #'org-table-copy-region
      "tt"  #'org-table-create-or-convert-from-region
      "tx"  #'org-table-cut-region
      "te"  #'org-table-edit-field
      "tv"  #'org-table-eval-formula
      "t-"  #'org-table-insert-hline
      "tp"  #'org-table-paste-rectangle
      "t#"  #'org-table-rotate-recalc-marks
      "t0"  #'org-table-sort-lines
      "to"  #'org-table-toggle-coordinate-overlays
      "tg"  #'std::org::plot-table
      "tf"  #'std::org::table-recalc
      "tsl" #'std::org::table-switch-right
      "tsh" #'std::org::table-switch-left
      "+"   #'org-table-sum
      "?"   #'org-table-field-info))
#+END_SRC

**** Toggles

#+BEGIN_SRC emacs-lisp
  (std::after org
    (std::mode-leader-keybind 'org-mode
      "zh" #'org-toggle-heading
      "zl" #'org-toggle-link-display
      "zx" #'org-toggle-checkbox
      "zc" #'org-toggle-comment
      "zt" #'org-toggle-tag
      "zi" #'org-toggle-item
      "zo" #'org-toggle-ordered-property))
#+END_SRC

**** Agenda

#+BEGIN_SRC emacs-lisp
  (std::global-keybind "<f12>" #'org-agenda-list)

  (std::after org-agenda
    (std::evil-keybind 'evilified org-agenda-mode-map
      "J" #'std::evil::forward-five-lines
      "K" #'std::evil::backward-five-lines)

    (std::mode-leader-keybind 'org-agenda-mode
      "zh" #'org-habit-toggle-habits))
#+END_SRC

**** Source Blocks & Tangling

#+BEGIN_SRC emacs-lisp
  (std::after org
    (std::keybind org-src-mode-map
      [remap save-buffer] #'ignore
      "C-c C-c" #'org-edit-src-exit)

    (std::mode-leader-keybind 'org-mode
      "bt" #'org-babel-tangle
      "bv" #'org-babel-tangle-file))
#+END_SRC

**** Other

#+BEGIN_SRC emacs-lisp
  (std::after org

    (std::keybind org-mode-map
      "M-q" #'std::fill-dwim)

    (std::mode-leader-keybind 'org-mode
      "0"   #'org-sort
      "#"   #'org-update-statistics-cookies
      "C-y" #'org-copy-visible
      "C-p" #'org-set-property
      "C-f" #'org-footnote-action
      "C-o" #'org-open-at-point
      "C-e" #'org-edit-special
      "C-t" #'org-set-tags-command
      "P"   #'org-priority)

    (std::evil-keybind 'normal org-mode-map
      "-" #'org-cycle-list-bullet
      "t" #'org-todo))
#+END_SRC

** Shell
*** Functions

~std::shell::mode-hook~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::shell::mode-hook ()
    (evil-collection-init 'term)
    (std::set-local
     helm-show-completion-display-function nil
     helm-split-window-default-side        'same
     helm-turn-on-show-completion          nil
     scroll-margin                         0))
#+END_SRC

Autoloads
#+BEGIN_SRC emacs-lisp
  (std::autoload #'std::shell::mode-hook)
  (std::add-hooks #'std::shell::mode-hook
    (term-mode-hook eshell-mode-hook))
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after multi-term
    (setq multi-term-program (s-trim (shell-command-to-string "which fish"))))
#+END_SRC

** Shell Scripts
*** Functions

~std::fish-mode-hook~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::fish::mode-hook ()
    (setq imenu-generic-expression std::fish::imenu-expr))
#+END_SRC

Autoloads
#+BEGIN_SRC emacs-lisp
  (add-hook 'fish-mode-hook #'std::fish::mode-hook)
  (std::autoload #'std::fish::mode-hook)
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after company
    (setq
     company-shell-delete-duplicates nil
     company-shell-modes             nil
     company-fish-shell-modes        nil
     company-shell-use-help-arg      t)

    (setq company-backends-fish-mode
          '((company-dabbrev-code company-files company-shell company-shell-env company-fish-shell :with company-yasnippet))))

  (defconst std::fish::imenu-expr
    (list
     (list
      "Function"
      (rx (group-n 1 (seq bol "function" (1+ space)))
          (group-n 2 (1+ (or alnum (syntax symbol)))) symbol-end)
      2)

     (list
      "Variables"
      (rx bol "set" (1+ space) (0+ "-" (1+ alpha) (1+ space))
          (group-n 1 symbol-start (1+ (or word "_"))))
      1)))
#+END_SRC

** Helm
*** Load Setup

#+BEGIN_SRC emacs-lisp
  (std::autoload-with "Helm"
    (completing-read
      read-directory-name
      read-string read-from-minibuffer
      std::org-files)
    (require 'helm))
#+END_SRC

*** Functions

~std::org-helm-headings~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (autoload 'helm-source-org-headings-for-files "helm-org")

  (defun std::org-in-buffer-headings ()
    "Slightly retooled ~helm-org-in-buffer-headings~ to have the candidates retain their fontification."
    (interactive)
    (helm :sources (helm-source-org-headings-for-files
                    (list (current-buffer)))
          :candidate-number-limit 99999
          :preselect (helm-org-in-buffer-preselect)
          :truncate-lines helm-org-truncate-lines
          :buffer "*helm org inbuffer*"))
#+END_SRC

~std::helm-semantic-or-imenu~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::helm-semantic-or-imenu ()
      "Same as `helm-semantic-or-imenu', but will call `std::org-helm-headings' in org-mode buffers."
      (interactive)
      (if (eq major-mode 'org-mode)
          (std::org-in-buffer-headings)
        (call-interactively #'helm-semantic-or-imenu)))
#+END_SRC

Autoloads
#+BEGIN_SRC emacs-lisp
  (std::autoload #'std::org-helm-headings #'std::helm-semantic-or-imenu)
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after helm
    (setq
     helm-ag-base-command              "ag -f --nocolor --nogroup --depth 999999 --smart-case --recurse"
     helm-imenu-delimiter              ": "
     helm-move-to-line-cycle-in-source t
     helm-swoop-use-line-number-face   t))
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::leader-keybind
    "hi"  #'std::helm-semantic-or-imenu
    "saa" #'helm-do-ag-this-file)

  (std::after helm
    (std::keybind helm-map
      "M-j" #'helm-next-source
      "M-k" #'helm-previous-source))
#+END_SRC

** Rust
*** Functions

~std::rust::build-rusty-tags~
#+BEGIN_SRC emacs-lisp
  (std::after rust-mode
    (defun std::rust::build-rusty-tags ()
      (interactive)
      (make-thread
       (lambda ()
         (-let [default-directory (projectile-project-root)]
           (call-process-shell-command "rusty-tags emacs")
           (call-process-shell-command "mv rusty-tags.emacs TAGS")
           (message "Rusty tags rebuilt."))))))
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::after "racer"
    (evil-define-key 'normal racer-mode-map      (kbd "M-.") #'racer-find-definition)
    (evil-define-key 'insert racer-mode-map      (kbd "M-.") #'racer-find-definition)
    (evil-define-key 'normal racer-help-mode-map (kbd "q")   #'kill-buffer-and-window)

    (std::mode-leader-keybind 'rust-mode
      "f"   #'rust-format-buffer
      "a"   #'rust-beginning-of-defun
      "e"   #'rust-end-of-defun
      "d"   #'racer-describe
      "C-t" #'std::rust::build-rusty-tags))
#+END_SRC

*** Settings

Add *company-dabbrev-code* to front row of completion backends.
#+BEGIN_SRC emacs-lisp
  (std::after "rust-mode"
    (setq racer-rust-src-path "~/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/src"
          company-backends-rust-mode
          '((company-capf :with company-dabbrev-code company-yasnippet)
            (company-dabbrev-code company-gtags company-etags company-keywords :with company-yasnippet)
            (company-files :with company-yasnippet)
            (company-dabbrev :with company-yasnippet))))
#+END_SRC

** Projectile
*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::after projectile
    (std::leader-keybind
      "pg"  nil
      "pt"  #'projectile-find-tag
      "psa" #'helm-projectile-ag
      "pgs" #'std::projectile::magit-status
      "pC"  #'projectile-cleanup-known-projects))
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after projectile
    (setq projectile-switch-project-action #'project-find-file))
#+END_SRC

** Flycheck
*** Functions

~std::flycheck::next-error~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (std::after flycheck
    (defun std::flycheck::next-error ()
      "Move to the next flycheck error.
  Start searching from the top if point is part the last error."
      (interactive)
      (-let [it (flycheck-next-error-pos 1)]
        (if (and it
                 (not (and (equal (point) (1- (point-min)))
                           (equal (1- (point-min)) it))))
            (goto-char it)
          (--if-let (save-excursion
                      (goto-char (point-min))
                      (flycheck-next-error-pos 1))
              (goto-char it)
            (message "No more Flycheck errors."))))))
#+END_SRC

~std::flycheck::previous-error~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (std::after flycheck
    (defun std::flycheck::previous-error ()
      "Move to the previous flycheck error.
  Start searching from the bottom if point is part the first error."
      (interactive)
      (-let [it (flycheck-next-error-pos -1)]
        (if (and it
                 (not (and (equal (point) (point-min))
                           (equal (point-min) it))))
            (goto-char it)
          (--if-let (save-excursion
                      (goto-char (point-max))
                      (flycheck-next-error-pos -1))
              (goto-char it)
            (message "No more Flycheck errors."))))))
#+END_SRC

Autoloads
#+BEGIN_SRC emacs-lisp
  (std::autoload
   #'std::flycheck::next-error
   #'std::flycheck::previous-error)
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after flycheck
    (setq
     flycheck-check-syntax-automatically '(mode-enabled save idle-change)
     flycheck-idle-change-delay          10
     flycheck-pos-tip-timeout            999))
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::after flycheck

    (evil-leader/set-key
      "ee"    #'flycheck-buffer
      "e C-e" #'flycheck-mode)

    (define-key evil-normal-state-map (kbd "C-.") #'std::flycheck::next-error)
    (define-key evil-normal-state-map (kbd "C-,") #'std::flycheck::previous-error))
#+END_SRC

** Version Control
*** Functions

#+BEGIN_SRC emacs-lisp
  (std::after magit
    (defun std::magit::org-reveal-on-visit ()
      (when (eq 'org-mode major-mode)
        (org-reveal)))
    (add-hook 'magit-diff-visit-file-hook #'std::magit::org-reveal-on-visit))
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after magit
    (setq
     magit-display-buffer-function              #'magit-display-buffer-fullframe-status-v1
     magit-repository-directories               '(("~/Documents/git/" . 1))
     magit-save-repository-buffers              'dontask
     git-commit-summary-max-length              120
     magit-section-visibility-indicator         nil
     magit-diff-highlight-hunk-region-functions '(magit-diff-highlight-hunk-region-using-face)))

  (std::after git-gutter
    (setq git-gutter-fr:side 'left-fringe))
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::after magit
    (std::keybind
        (magit-mode-map
         magit-status-mode-map
         magit-log-mode-map
         magit-diff-mode-map
         magit-branch-section-map
         magit-untracked-section-map
         magit-file-section-map
         magit-status-mode-map
         magit-hunk-section-map
         magit-stash-section-map
         magit-stashes-section-map
         magit-staged-section-map
         magit-unstaged-section-map)
      "J"   #'std::evil::forward-five-lines
      "K"   #'std::evil::backward-five-lines
      "M-j" #'magit-section-forward-sibling
      "M-k" #'magit-section-backward-sibling
      ",u"  #'magit-section-up
      ",u"  #'magit-section-up
      ",1"  #'magit-section-show-level-1-all
      ",2"  #'magit-section-show-level-2-all
      ",3"  #'magit-section-show-level-3-all
      ",4"  #'magit-section-show-level-4-all
      "M-1" #'winum-select-window-1
      "M-2" #'winum-select-window-2
      "M-3" #'winum-select-window-3
      "M-4" #'winum-select-window-4))
#+END_SRC

** Dired
A simple sunrise-commander-ish two-pane setup, smart enough to remember the last window layout.
*** Variables

#+BEGIN_SRC emacs-lisp
  (defvar std::dired::saved-positions nil)
  (defvar std::dired::saved-window-config nil)
  (defvar std::dired::cache-file (f-join user-emacs-directory ".cache" "std-dired-cache"))
#+END_SRC

*** Evil State

A dired evil state to get rid of the cursor and to have a single keymap

#+BEGIN_SRC emacs-lisp
  (std::after dired
    (evil-define-state dired
      "Dired state"
      :cursor '(bar . 0)
      :enable (motion)))
#+END_SRC

*** Functions
**** Top level

~std::dired~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::dired ()
    (interactive)
    (require 'dired+)
    (setq std::dired::saved-window-config (current-window-configuration))
    (delete-other-windows)
    (unless std::dired::saved-positions
      (-let [(left right)
             (->> std::dired::cache-file
                  (f-read)
                  (s-split "\n"))]
        (setf std::dired::saved-positions (list left right))))
    (-let [(left right) (--map (if (file-exists-p it) it "~")
                               std::dired::saved-positions)]
      (dired left)
      (save-selected-window
        (split-window-right-and-focus)
        (dired right))))
#+END_SRC

~std::dired::mode-hook~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::dired::mode-hook ()
    (setq diredp-hide-details-initially-flag t)
    (hl-line-mode)
    (evil-dired-state))
#+END_SRC

Autoloads
#+BEGIN_SRC emacs-lisp
  (std::autoload
   #'std::dired #'std::dired::mode-hook)
#+END_SRC

**** Dired Internal

#+BEGIN_SRC emacs-lisp
  (std::after dired+

    (defhydra std::dired::goto-hydra (:exit t :hint nil)
      ("h" (lambda () (interactive) (dired "~"))           "$HOME")
      ("d" (lambda () (interactive) (dired "~/Documents")) "Documents")
      ("w" (lambda () (interactive) (dired "~/Downloads")) "Downloads")
      ("v" (lambda () (interactive) (dired "~/Videos"))    "Videos")
      ("o" (lambda () (interactive) (dired "~/Dropbox"))   "Dropbox")
      ("p" (lambda () (interactive) (dired "~/Pictures"))  "Pictures")
      ("m" (lambda () (interactive) (dired "~/Music"))     "Music")
      ("M" (lambda () (interactive) (dired "/run/media"))  "/run/media")
      ("q" nil "cancel"))

    (defun std::dired::quit ()
      (interactive)
      (let ((left) (right))
        (winum-select-window-1)
        (setf left default-directory)
        (winum-select-window-2)
        (setf right default-directory
              std::dired::saved-positions (list left right))
        (unless (f-exists? std::dired::cache-file)
          (f-touch std::dired::cache-file))
        (f-write (std::fmt "${left}\n${right}") 'utf-8 std::dired::cache-file))
      (set-window-configuration std::dired::saved-window-config)
      (--each (buffer-list)
        (when (eq 'dired-mode (buffer-local-value 'major-mode it))
          (kill-buffer it))))

    (defun std::dired::mark-up ()
      (interactive)
      (call-interactively #'dired-mark)
      (previous-line 2))

    (defun std::dired::open-externally ()
      (interactive)
      (call-process-shell-command
       (format "xdg-open %s &"
               (shell-quote-argument (dired-get-filename)))))

    (defun std::dired::filesize ()
      (interactive)
      (-if-let (file (dired-get-filename nil :no-error))
          (let* ((cmd (if (f-directory? file) "du -sh \"%s\"" "ls -sh \"%s\""))
                 (output (->> file
                              (format cmd)
                              ;; (shell-quote-argument)
                              (shell-command-to-string)
                              (s-trim))))
            (-let [(size file) (s-split-up-to (rx (1+ whitespace)) output 1)]
              (message
               "%s : %s"
               (propertize file 'face 'font-lock-keyword-face)
               (propertize size 'face 'font-lock-string-face))))
        (message (propertize "---" 'face 'font-lock-string-face)))))
#+END_SRC

**** Wdired

#+BEGIN_SRC emacs-lisp
  (std::after wdired

    (defun std::dired::finish-wdired ()
      (interactive)
      (wdired-finish-edit)
      (evil-dired-state))

    (defun std::dired::abort-wdired ()
      (interactive)
      (wdired-abort-changes)
      (evil-dired-state)))
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (add-hook 'dired-mode-hook #'std::dired::mode-hook)

  (std::after dired+
    (setf dired-listing-switches "-alh --group-directories-first")
    (unless (file-exists-p std::dired::cache-file)
      (f-touch std::dired::cache-file)))
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::leader-keybind "ad" #'std::dired)

  (defmacro std::dired::dwim-target-wrap (command)
    (let* ((command (cadr command))
           (command-name (symbol-name command))
           (format-name (s-replace "dired-" "dired::" (symbol-name command)))
           (new-name (format (if (s-starts-with? "dired" format-name)
                                 "std::%s"
                               "std::dired::%s")
                             format-name)))
      (-let [name (intern new-name)]
        `(progn
           (defun ,name (&optional arg)
             (format "Run %s. Set `dired-dwim-target' to t with a prefix arg." ,command-name)
             (interactive "P")
             (-let [dired-dwim-target arg] (,command)))
           #',name))))

  (std::after dired+

    (std::dired::dwim-target-wrap #'dired-do-copy)
    (std::dired::dwim-target-wrap #'dired-do-rename)
    (std::dired::dwim-target-wrap #'dired-do-symlink)

    (std::keybind evil-dired-state-map
      "o"     nil
      ","     nil
      "c"     nil
      "RET"   #'dired-find-file
      "gh"    #'std::dired::goto-hydra/body
      "gr"    #'revert-buffer
      "y"     #'std::dired::do-copy
      "R"     #'std::dired::do-rename
      "S"     #'std::dired::do-symlink
      "cd"    #'dired-create-directory
      ", C-e" #'wdired-change-to-wdired-mode
      "("     #'global-dired-hide-details-mode
      "D"     #'dired-do-delete
      "I"     #'std::dired::filesize
      "ox"    #'std::dired::open-externally
      "q"     #'std::dired::quit
      "J"     #'std::evil::forward-five-lines
      "K"     #'std::evil::backward-five-lines
      "M-j"   #'dired-mark
      "M-k"   #'std::dired::mark-up
      "l"     #'dired-find-file
      "h"     #'diredp-up-directory
      "Z"     #'dired-do-compress
      "M-z"   #'dired-do-compress-to)

    (std::after wdired
      (std::keybind wdired-mode-map
        "C-c C-c" #'std::dired::finish-wdired
        "C-c C-k" #'std::dired::abort-wdired)))
#+END_SRC

** Treemacs

I don't use the treemacs layer directly, loading the local development version instead. Without loading the layer
the custom ~spacemacs-treemacs-face~ is not defined and leads to display errors and an empty modeline.

#+BEGIN_SRC emacs-lisp
  (defface spacemacs-treemacs-face
    `((t (:foreground "#1a1a1a" :background "MediumPurple1")))
    "Custom spacemacs-treemacs face for the modeline.")
#+END_SRC

Flycheck should be turned on for treemacs, but not all elisp files.

#+BEGIN_SRC emacs-lisp
  (defun std::elisp::treemacs-flycheck-activate ()
    (when (s-matches? (rx "treemacs" (0+ (or "-" (1+ alnum))) ".el")
                      (buffer-name))
      (flycheck-mode)))
  (add-hook 'find-file-hook #'std::elisp::treemacs-flycheck-activate)
#+END_SRC

Load up the local repository. Settings are mostly default, minor modes are on. Everything's wrapped up in a single when
for easy deactivation.

#+BEGIN_SRC emacs-lisp
  (when (file-exists-p "~/Documents/git/treemacs/")
    (use-package treemacs
      :load-path "~/Documents/git/treemacs/src/elisp"
      :defer t
      :init
      (std::after winum
        (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
      :config
      (progn
        (setq treemacs-follow-after-init          t
              treemacs-width                      35
              treemacs-indentation                2
              treemacs-collapse-dirs              3
              treemacs-silent-refresh             nil
              treemacs-change-root-without-asking nil
              treemacs-sorting                    'alphabetic-desc
              treemacs-show-hidden-files          t
              treemacs-never-persist              nil
              treemacs-goto-tag-strategy          'refetch-index)
        (treemacs-follow-mode t)
        (treemacs-filewatch-mode t))
      :bind
      (:map global-map
            ("M-0"       . treemacs-select-window)
            ("C-c 1"     . treemacs-delete-other-windows)
            :map spacemacs-default-map
            ("ft"    . treemacs)
            ("f C-t" . treemacs-find-file)))

    (use-package treemacs-evil
      :load-path "~/Documents/git/treemacs/src/extra"
      :after treemacs)

    (use-package treemacs-projectile
      :load-path "~/Documents/git/treemacs/src/extra"
      :after treemacs)

    (use-package treemacs-icons-dired
      :after dired+
      :load-path "~/Documents/git/treemacs/src/extra"
      :config (treemacs-icons-dired-mode))

    (use-package treemacs-magit
      :load-path "~/Documents/git/treemacs/src/extra"
      :after (treemacs magit)))
#+END_SRC

The only deviation from the defaults

#+BEGIN_SRC emacs-lisp
(setf treemacs-no-delete-other-windows nil)
#+END_SRC

** Finance
*** Variables

#+BEGIN_SRC emacs-lisp
  (defvar std::ledger::save-window-config nil)
  (defconst std::ledger::month-separator-pattern (rx "+++ " (group-n 2 (1+ alnum)) " +++" eol))
  (defconst std::ledger::dir (expand-file-name (std::fmt "${*ORGDIR*}/Ledger")))
  (defconst std::ledger::months '((1 . "Januar")   (2 . "Februar")   (3 . "März")
                                  (4 . "April")    (5 . "Mai")       (6 . "Juni")
                                  (7 . "Juli")     (8 . "August")    (9 . "September")
                                  (10 . "Oktober") (11 . "November") (12 . "Dezemper")))
#+END_SRC

*** Functions
**** Top Level

~std::ledger~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::ledger ()
    (interactive)
    (require 'calendar)
    (-let [pcmds (std::fmt "${*ORGDIR*}/Ledger/ledger.el")]
      (when (file-exists-p pcmds)
        (load-file pcmds)))
    (let* ((date (calendar-current-date))
           (year (cl-third (calendar-current-date)))
           (main-file (std::fmt "${std::ledger::dir}/Ledger.ledger"))
           (year-file (std::fmt "${std::ledger::dir}/${year}.ledger")))
      (setf std::ledger::save-window-config (current-window-configuration))
      (delete-other-windows)
      (find-file year-file)
      (split-window-right)
      (save-selected-window
        (-let [full-width (* 2 (window-width))]
          (shrink-window-horizontally (- (/ full-width 7))))
        (other-window 1)
        (find-file main-file))
      (std::ledger::goto-current-month)))
#+END_SRC

~std::ledger::mode-hook~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::ledger::mode-hook ()
    (outline-minor-mode)
    (smartparens-mode)
    (evil-ledger-mode)
    (flyspell-mode-off)
    (std::set-local
     ledger-accounts-file     (std::fmt "${std::ledger::dir}/Ledger.ledger")
     outline-regexp           (rx bol "+++ ")
     imenu-generic-expression `(("Monat" ,std::ledger::month-separator-pattern 2))))
#+END_SRC

Autoloads
#+BEGIN_SRC emacs-lisp
  (std::autoload
   #'std::ledger
   #'std::ledger::mode-hook)
  (add-hook 'ledger-mode-hook #'std::ledger::mode-hook)
#+END_SRC

**** Internal

~std::ledger::save~
#+BEGIN_SRC emacs-lisp
  (std::after ledger-mode
    (defun std::ledger::save ()
      "First `ledger-mode-clean-buffer', then `save-buffer'."
      (interactive)
      (-let [p (point)]
        (when (buffer-modified-p)
          (unwind-protect (ledger-mode-clean-buffer)
            (save-buffer)))
        (goto-char p))))
#+END_SRC

~std::ledger::finish~
#+BEGIN_SRC emacs-lisp
  (std::after ledger-mode
    (defun std::ledger::finish ()
      (interactive)
      (cl-loop
       for buf in (buffer-list)
       if (eq 'ledger-mode (buffer-local-value 'major-mode buf)) do
       (with-current-buffer buf
         (when (buffer-file-name)
           (save-buffer)
           (kill-buffer))))
      (when std::ledger::save-window-config
        (set-window-configuration std::ledger::save-window-config))))
#+END_SRC

~std::ledger::magic-tab~
#+BEGIN_SRC emacs-lisp
  (std::after ledger-mode
    (defun std::ledger::magic-tab ()
      (interactive)
      (if (s-matches? outline-regexp (thing-at-point 'line t))
          (outline-toggle-children)
        (ledger-magic-tab))))
#+END_SRC

~std::ledger::goto-current-month~
#+BEGIN_SRC emacs-lisp
  (std::after ledger-mode
    (defun std::ledger::goto-current-month ()
      (interactive)
      (-let [month (-> (calendar-current-date)
                       (car)
                       (alist-get std::ledger::months))]
        (save-match-data
          (-let [start (point)]
            (goto-char 0)
            (if (search-forward (std::fmt "+++ ${month}") nil :no-error)
                (forward-line 1)
              (message "'%s' not found." month)
              (goto-char start)))))))
#+END_SRC

~std::ledger::forward~ & ~std::ledger::backward~
#+BEGIN_SRC emacs-lisp
  (std::after ledger-mode
    (defun std::ledger::forward ()
      (interactive)
      (if (s-matches? std::ledger::month-separator-pattern
                      (thing-at-point 'line))
          (save-match-data
            (end-of-line)
            (search-forward-regexp std::ledger::month-separator-pattern nil :no-error))
        (call-interactively #'evil-ledger-forward-xact)))

    (defun std::ledger::backward ()
      (interactive)
      (if (s-matches? std::ledger::month-separator-pattern
                      (thing-at-point 'line))
          (save-match-data
            (beginning-of-line)
            (search-backward-regexp std::ledger::month-separator-pattern nil :no-error))
        (call-interactively #'evil-ledger-backward-xact))))
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::leader-keybind "aL" #'std::ledger)

  (std::after ledger-mode

    (std::keybind ledger-mode-map
      "M-J"   #'std::ledger::forward
      "M-K"   #'std::ledger::backward
      "<tab>" #'std::ledger::magic-tab
      "M-q"   #'ledger-post-align-dwim
      [remap save-buffer] #'std::ledger::save)

    (std::mode-leader-keybind 'ledger-mode
      "C-w" #'std::ledger::finish
      "c"   #'std::ledger::goto-current-month
      "L"   #'std::ledger::parse-csv
      "s"   #'ledger-sort-buffer
      "S"   #'ledger-sort-region
      "o"   #'ledger-occur-mode
      "y"   #'ledger-copy-transaction-at-point
      "d"   #'ledger-delete-current-transaction
      "r"   #'ledger-report
      "R"   #'ledger-reconcile))
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after ledger-mode

    (defface std::ledger::month-face
      '((t (:foreground "#ccb18b" :bold t :height 1.1 :background "#333366" :box (:line-width -1 :color "#1a1a1a"))))
      ""
      :group 'std)

    (font-lock-add-keywords
     'ledger-mode
     `((,(rx (group-n
              1
              bol
              "+++ "
              (1+ alnum)
              " +++"
              "\n"))
        1 'std::ledger::month-face t))
     'prepend)

    (setq ledger-default-date-format           ledger-iso-date-format
          ledger-mode-should-check-version     nil
          ledger-post-amount-alignment-column  62
          ledger-post-account-alignment-column 2
          ledger-clear-whole-transactions      t
          company-backends-ledger-mode         '((company-capf company-dabbrev :with company-yasnippet))))
#+END_SRC

** Email
*** Functions

#+BEGIN_SRC emacs-lisp
  (std::after mu4e
    (defun std::mail::find-thunderbird-imap-dir ()
      (-let [dot-thunderbird (expand-file-name "~/.thunderbird")]
        (when (f-exists? dot-thunderbird)
          (-when-let (maildir (--find (and (f-directory? it) (member "ImapMail" (directory-files it)))
                                      (directory-files dot-thunderbird :full)))
            (f-join dot-thunderbird maildir "ImapMail"))))))
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after mu4e

    (global-mu4e-conversation-mode)

    (setq mu4e-confirm-quit nil
          mu4e-use-fancy-chars nil
          mu4e-maildir (std::mail::find-thunderbird-imap-dir)
          mu4e-headers-fields '((:human-date . 10)   (:flags . 6)
                                (:mailing-list . 10) (:from . 22)
                                (:subject . 85)      (:tags . 10)))

    (add-to-list 'mu4e-bookmarks
                 (make-mu4e-bookmark
                  :name "Github Messages"
                  :query "github"
                  :key ?g)))
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::after mu4e

    (std::keybind mu4e-main-mode-map
      "u" #'mu4e-update-index)

    (std::evil-keybind 'evilified (mu4e-headers-mode-map mu4e-view-mode-map mu4e-conversation-map)
      "J" #'std::evil::forward-five-lines
      "K" #'std::evil::backward-five-lines))
#+END_SRC

** Colors
*** Settings

#+BEGIN_SRC emacs-lisp
  (std::add-hooks #'rainbow-mode
    (emacs-lisp-mode-hook
     conf-mode-hook
     help-mode-hook
     css-mode-hook))

  (add-hook 'prog-mode-hook    #'rainbow-delimiters-mode-enable)
  (add-hook 'snippet-mode-hook #'rainbow-delimiters-mode-disable)
#+END_SRC

** Elfeed
*** Evil State

#+BEGIN_SRC emacs-lisp
  (std::after elfeed
    (evil-define-state elfeed
      "Evil elfeed state."
      :cursor '(bar . 0)
      :enable (evilified)))
#+END_SRC

*** Functions

~std::elfeed::mode-hook~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (std::after elfeed
    (defun std::elfeed::mode-hook ()
      (evil-elfeed-state)))
#+END_SRC

~std::elfeed::play-with-mpv~
#+BEGIN_SRC emacs-lisp
  (std::after elfeed

    (defun std::elfeed::visit-entry-dwim (&optional arg)
      (interactive "P")
      (if arg
          (elfeed-search-browse-url)
        (-let [entry (if (eq major-mode 'elfeed-show-mode) elfeed-show-entry (elfeed-search-selected :single))]
          (if (s-matches? (rx "https://www.youtube.com/watch" (1+ any)) (elfeed-entry-link entry))
              (let* ((quality (completing-read "Max height resolution (0 for unlimited): " '("0" "480" "720" "1080")))
                     (arg (if (= 0 (string-to-number quality)) "" (std::fmt "--ytdl-format=[height<=?${quality}]"))))
                (message "Opening %s with height ≤ %s with mpv..."
                         (propertize (elfeed-entry-link entry) 'face 'font-lock-string-face)
                         (propertize quality 'face 'font-lock-keyword-face))
                (elfeed-untag entry 'unread)
                (start-process "elfeed-mpv" nil "mpv" arg (elfeed-entry-link entry)))
            (if (eq major-mode 'elfeed-search-mode)
                (elfeed-search-browse-url)
              (elfeed-show-visit)))))))
#+END_SRC

~std::elfeed::ignore-entry~
#+begin_src emacs-lisp
  (std::after elfeed
    (defun std::elfeed::ignore-entry ()
      (interactive)
      (-let [entries (elfeed-search-selected)]
        (elfeed-tag entries 'ignore)
        (mapc #'elfeed-search-update-entry entries)
        (elfeed-search-update :force))))
#+end_src

Autoloads
#+BEGIN_SRC emacs-lisp
  (std::autoload #'std::elfeed::mode-hook)
  (add-hook 'elfeed-search-mode-hook #'std::elfeed::mode-hook)
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after elfeed
    (setf elfeed-db-directory  (std::fmt "${*ORGDIR*}/Elfeed-DB")
          elfeed-search-filter "@6-months-ago -ignore"
          elfeed-search-face-alist
          '((unread   elfeed-search-unread-title-face)
            (vids     font-lock-constant-face)
            (blog     font-lock-doc-face)
            (reddit   font-lock-variable-name-face)
            (webcomic font-lock-builtin-face))))
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::after elfeed
    (std::keybind elfeed-search-mode-map
      "J" #'std::evil::forward-five-lines
      "K" #'std::evil::backward-five-lines
      "i" #'std::elfeed::ignore-entry
      [remap elfeed-search-browse-url] #'std::elfeed::visit-entry-dwim))
#+END_SRC

** Spell Checking
*** Settings

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook #'flyspell-mode)
  (add-hook 'markdown-mode-hook #'flyspell-mode)
  (add-hook 'org-mode-hook #'flyspell-mode-off)
#+END_SRC

* Single Package Configurations
** Swiper
*** Functions

~std::swipe-symbol-at-point~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::swipe-symbol-at-point ()
    (interactive)
    (-if-let (sym (thing-at-point 'symbol t))
        (swiper sym)
      (message "No symbol found.")))
#+END_SRC

Autoloads
#+BEGIN_SRC emacs-lisp
  (std::autoload #'std::swipe-symbol-at-point)
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after swiper
    (setq ivy-height 4)
    (push 'org-mode swiper-font-lock-exclude))
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::global-keybind "C-s" #'swiper)

  (std::keybind (evil-normal-state-map evil-insert-state-map evil-visual-state-map evil-motion-state-map)
    "C-M-s" #'std::swipe-symbol-at-point)
#+END_SRC

** Anzu

*** Functions

~std::defun-query-replace~
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::defun-query-replace (&optional arg)
    (interactive "P")
    (if arg
        (progn (mark-defun)
               (call-interactively 'anzu-query-replace))
      (anzu-query-replace-at-cursor-thing)))
#+END_SRC

Autoloads
#+BEGIN_SRC emacs-lisp
  (std::autoload #'std::defun-query-replace)
  (std::leader-keybind
   "üü" #'anzu-query-replace
   "üf" #'std::defun-query-replace)
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after anzu
    (setf anzu-cons-mode-line-p nil))
#+END_SRC

** Yasnippet
*** Functions

~std::yas::activate-fundamental-mode~
#+BEGIN_SRC emacs-lisp
  (defun std::yas::activate-fundamental-mode ()
    (yas-activate-extra-mode 'fundamental-mode))
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after yasnippet
    (setf yas-snippet-dirs (list (std::fmt "${*SPACEMACSDIR*}/snippets"))))

  (add-hook 'yas-minor-mode-hook #'std::yas::activate-fundamental-mode)
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::after yasnippet
    (define-key evil-insert-state-map (kbd "C-l") #'yas-expand))
#+END_SRC

*** Enable Whitespace mode

Hoping it'll help with the issue of the extra newline in snippets
#+BEGIN_SRC emacs-lisp
  (add-hook 'snippet-mode-hook #'whitespace-mode)
#+END_SRC

** i3wm-config-mode

#+BEGIN_SRC emacs-lisp
  (std::after conf-mode
    (require 'i3wm-config-mode))
#+END_SRC

** Writeroom mode
*** Functions

#+BEGIN_SRC emacs-lisp 
  (std::after writeroom-mode
    (defun std::writeroom::toggle-line-numbers ()
      (if writeroom-mode
          (display-line-numbers-mode -1)
        (display-line-numbers-mode t))))
#+END_SRC

*** Settings
#+BEGIN_SRC emacs-lisp
  (spacemacs|add-toggle writeroom
    :mode writeroom-mode
    :documentation "Disable visual distractions."
    :evil-leader "TW")

  (std::after writeroom-mode
    (setq writeroom-width                120
          writeroom-extra-line-spacing   0
          writeroom-bottom-divider-width 0
          writeroom-global-effects
          (delete 'writeroom-set-fullscreen writeroom-global-effects))

    (add-hook 'writeroom-mode-hook #'std::writeroom::toggle-line-numbers))
#+END_SRC

** Vimish fold

A fallback in case evil's own folding is not sufficient
#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "zva") #'vimish-fold-avy)
  (define-key evil-normal-state-map (kbd "zvd") #'vimish-fold-delete)
  (define-key evil-normal-state-map (kbd "zvv") #'vimish-fold-toggle)
  (define-key evil-normal-state-map (kbd "zvz") #'vimish-fold)
#+END_SRC

** Helpful
*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::global-keybind "C-x ß" #'helpful-at-point)
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (add-hook 'helpful-mode-hook #'evil-motion-state)
#+END_SRC

** Eros
*** Functions

Evaluate last s-expr on the right spot, calling into eros if it's on.
#+BEGIN_SRC emacs-lisp :tangle autoloads.el
  (defun std::eval-last-sexp ()
    (interactive)
    (autoload #'eros-eval-last-sexp "eros")
    (let ((func (if eros-mode 'eros-eval-last-sexp 'eval-last-sexp)))
      (if (and (evil-normal-state-p)
               (string= ")" (string (or (char-after) 0))))
          (save-excursion
            (forward-char)
            (call-interactively func))
        (call-interactively func))))
#+END_SRC

Autoloads
#+BEGIN_SRC emacs-lisp
  (std::autoload #'std::eval-last-sexp)
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (eros-mode t)
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::global-keybind "C-x C-e" #'std::eval-last-sexp)
  (std::mode-leader-keybind 'emacs-lisp-mode "ee" #'std::eval-last-sexp)
#+END_SRC

** Multi-Compile
*** Functions

~std::multi-compile~
#+BEGIN_SRC emacs-lisp
  (defun std::multi-compile ()
    (interactive)
    (-let [default-directory
            (condition-case _
                (projectile-project-root)
              (error (--if-let (buffer-file-name)
                         (if (f-directory? it)
                             it
                           (f-parent it))
                       "~/")))]
      (call-interactively #'multi-compile-run)))

  (std::leader-keybind "pc" #'std::multi-compile)
#+END_SRC

*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after multi-compile
    (setq multi-compile-alist
          '((emacs-lisp-mode ("Test" . "make test")
                             ("Lint" . "make lint")
                             ("Compile" . "make compile")
                             ("Clean" . "make clean")))
          multi-compile-completion-system 'helm))
#+END_SRC

** Avy
*** Settings

#+BEGIN_SRC emacs-lisp
  (std::after avy
    (setf avy-all-windows      nil
          avy-case-fold-search nil))
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::evil-keybind (normal motion visual) global-map
    "ß" #'evil-avy-goto-char-2)
#+END_SRC

** Make
*** Functions

#+BEGIN_SRC emacs-lisp
  (std::after make-mode

    (defun std::make::mode-hook ()
      (setf company-backends '((company-capf company-dabbrev-code :with company-yasnippet))))
    (add-hook 'makefile-mode-hook #'std::make::mode-hook))
#+END_SRC

** Smartparens
*** Settings

#+BEGIN_SRC emacs-lisp
  (show-smartparens-global-mode t)

  (require 'smartparens-config)

  (std::add-hooks #'smartparens-mode
    (prog-mode-hook text-mode-hook comint-mode-hook))

  (setq sp-show-pair-delay
        (or (bound-and-true-p sp-show-pair-delay) 0.2)
        sp-show-pair-from-inside t
        sp-cancel-autoskip-on-backward-movement nil
        sp-highlight-pair-overlay nil
        sp-highlight-wrap-overlay nil
        sp-highlight-wrap-tag-overlay nil)
#+END_SRC

*** Keybinds

#+BEGIN_SRC emacs-lisp
  (std::leader-keybind
   "kr" #'sp-raise-sexp
   "kw" #'sp-wrap-round
   "ks" #'sp-forward-slurp-sexp
   "kS" #'sp-backward-slurp-sexp
   "kb" #'sp-forward-barf-sexp
   "kB" #'sp-backward-barf-sexp
   "js" #'sp-split-sexp
   "jn" #'sp-newline)
#+END_SRC

** Which-Key

#+BEGIN_SRC emacs-lisp
  (which-key-mode -1)
#+END_SRC

** Expand Region

#+BEGIN_SRC emacs-lisp
  (std::leader-keybind
   "v" #'er/expand-region)

  (std::after expand-region
    (setq expand-region-contract-fast-key "c"
          expand-region-reset-fast-key    "r"))
#+END_SRC

* Modeline

A simple mode-line implementation based on doom.

** Faces

#+BEGIN_SRC emacs-lisp
  (defface std::modeline::selected-separator-face
    '((t (:background "#559955")))
    ""
    :group 'std)

  (defface std::modeline::not-selected-separator-face
    '((t (:background "#25252a")))
    ""
    :group 'std)

  (defface std::modeline::num-face
    '((t (:foreground "#997799" :bold t)))
    ""
    :group 'std::modeline)

  (defface std::modeline::major-mode-face
    '((t (:foreground "#997799" :bold t)))
    ""
    :group 'std::modeline)

  (defface std::modeline::buffer-id-inactive
    '((t (:foreground "#c98459" :box "#000000")))
    ""
    :group 'std::modeline)
#+END_SRC

** Default

#+BEGIN_SRC emacs-lisp
  (require 'inline)
  (require 'doom-modeline)

  (declare-function winum-get-number "winum")
  (declare-function eyebrowse--get "eyebrowse")

  (defconst std::modeline::selected-window-xpm
    (doom-modeline--make-xpm 'std::modeline::selected-separator-face 5 30))

  (defconst std::modeline::unselected-window-xpm
    (doom-modeline--make-xpm 'std::modeline::not-selected-separator-face 5 30))

  (define-inline std::num-to-unicode (n)
    (inline-letevals (n)
      (inline-quote
       (pcase ,n
         (1 "➊") (2 "➋") (3 "➌") (4 "➍")  (5 "➎") (6 "➏")
         (7 "➐") (8 "➑") (9 "➒") (10 "➓") (_ ,n)))))

  (doom-modeline-def-segment std::modeline::window-number
    (--when-let (winum-get-number)
      (propertize (std::num-to-unicode it)
                  'face 'std::modeline::num-face)))

  (doom-modeline-def-segment std::modeline::desktop-number
    (propertize (std::num-to-unicode (eyebrowse--get 'current-slot))
                'face 'std::modeline::num-face))

  (doom-modeline-def-segment std::modeline::buffer-id
    (propertize (buffer-name)
                'face (if (doom-modeline--active) 'mode-line-buffer-id 'std::modeline::buffer-id-inactive)))

  (doom-modeline-def-segment std::modeline::window-bar
    (if (doom-modeline--active)
        std::modeline::selected-window-xpm
      std::modeline::unselected-window-xpm))

  (defconst std::modeline::major-mode-local-map
    (let ((map (make-sparse-keymap)))
      (define-key map [mode-line down-mouse-1]
        `(menu-item ,(purecopy "Menu Bar") ignore
                    :filter (lambda (_) (mouse-menu-major-mode-map))))
      (define-key map [mode-line mouse-2] 'describe-mode)
      (define-key map [mode-line down-mouse-3] mode-line-mode-menu)
      map))

  (doom-modeline-def-segment std::modeline::major-mode
    (propertize (format-mode-line mode-name)
                'mouse-face 'mode-line-highlight
                'local-map std::modeline::major-mode-local-map
                'face 'std::modeline::major-mode-face))

  (defconst std::modeline::flycheck-bullet-info  (concat (propertize " •%s" 'face 'doom-modeline-info)))
  (defconst std::modeline::flycheck-bullet-warn  (concat (propertize " •%s" 'face 'doom-modeline-warning)))
  (defconst std::modeline::flycheck-bullet-error (concat (propertize " •%s" 'face 'doom-modeline-urgent)))

  (doom-modeline-def-segment std::modeline::flycheck
    (when (bound-and-true-p flycheck-mode)
      (with-no-warnings
        (let* ((count    (flycheck-count-errors flycheck-current-errors))
               (warnings (alist-get 'warning count))
               (errors   (alist-get 'error count)))
          (concat (when warnings (format std::modeline::flycheck-bullet-warn warnings))
                  (when errors   (format std::modeline::flycheck-bullet-error errors)))))))

  (doom-modeline-def-modeline 'std
    '(""  std::modeline::window-bar
      " " std::modeline::window-number
      " " std::modeline::desktop-number
      " " std::modeline::buffer-id
      " " std::modeline::major-mode
      " " std::modeline::flycheck))

  (doom-modeline-set-modeline 'std :global-default)
#+END_SRC

** Magit

#+BEGIN_SRC emacs-lisp
  (std::after magit

    (doom-modeline-def-segment std::modeline::buffer-process
      mode-line-process)


    (doom-modeline-def-modeline 'magit
      '(""  std::modeline::window-bar
        " " std::modeline::window-number
        " " std::modeline::desktop-number
        " " std::modeline::buffer-id
        " " std::modeline::major-mode
        " " std::modeline::buffer-process))

    (defun std::modeline::magit-modeline ()
      (doom-modeline-set-modeline 'magit nil))

    (add-hook 'magit-mode-hook #'std::modeline::magit-modeline))
#+END_SRC

** Treemacs

#+BEGIN_SRC emacs-lisp
  (std::after treemacs

    (doom-modeline-def-modeline 'treemy
      '(""  std::modeline::window-bar
        " " std::modeline::desktop-number
        " " std::modeline::major-mode))

    (defun std::modeline::treemacs-modeline ()
      (doom-modeline-set-modeline 'treemy nil))

    (add-hook 'treemacs-mode-hook #'std::modeline::treemacs-modeline))
#+END_SRC

** Alignment for Pre-Existing Buffers

#+BEGIN_SRC emacs-lisp
  (std::idle 0.5 :no-repeat
    (dolist (buffer '("*Messages*" "*spacemacs*" "*Compile-Log*" "*scratch*"))
      (when (get-buffer buffer)
        (with-current-buffer buffer
          (setq-local mode-line-format (default-value 'mode-line-format))
          (doom-modeline-set-selected-window)))))
#+END_SRC

* Fonts
** Functions

~std::downscale~
#+BEGIN_SRC emacs-lisp
  (cl-defun std::downscale (font &key char start end (size 12))
    (set-fontset-font "fontset-default" `(,(or start char) . ,(or end char))
                      (font-spec :size size :name font)))
#+END_SRC

** Scaled Characters

Some unicode characters are displayed taller than the default text. Scrolling through such
characters will sometimes cause the cursor to be jumpy. To avoid that these unicode characters
need to be scaled down.

First the entirety of Font Awesome
#+BEGIN_SRC emacs-lisp
  (std::downscale "Font Awesome" :start #xf000 :end #xf2e0)
#+END_SRC

Then single characters, like those used for prettify-symbols
#+BEGIN_SRC emacs-lisp
  (std::downscale "Symbola" :char ?\⇛)
  (std::downscale "Symbola" :char ?\⭢)
  (std::downscale "Symbola" :char ?\⩵)
  (std::downscale "Symbola" :char ?\⮕)
  (std::downscale "Symbola" :char ?\⬅)
  (std::downscale "Symbola" :char ?\◉)
  (std::downscale "Symbola" :char ?\•)
  (std::downscale "Symbola" :char ?\⏵)
  (std::downscale "Symbola" :char ?\⏸)
  (std::downscale "Symbola" :char ?\⏹)
  (std::downscale "Symbola" :char ?\⏮)
  (std::downscale "Symbola" :char ?\⏭)
  (std::downscale "Symbola" :char ?\⏪)
  (std::downscale "Symbola" :char ?\⏩)
  (std::downscale "Symbola" :char ?\🔀)
  (std::downscale "Symbola" :char ?\🔁)
  (std::downscale "Symbola" :char ?\🔂)
  (std::downscale "Symbola" :char ?\❯)
  (std::downscale "Symbola" :char ?\✸)
  (std::downscale "Symbola" :char ?\✿)
  (std::downscale "Cantarell" :char ?\•)
  (std::downscale "DejaVu Sans" :char ?\➊ :size 14)
  (std::downscale "DejaVu Sans" :char ?\➋ :size 14)
  (std::downscale "DejaVu Sans" :char ?\➌ :size 14)
  (std::downscale "DejaVu Sans" :char ?\➍ :size 14)
  (std::downscale "DejaVu Sans" :char ?\➎ :size 14)
  (std::downscale "DejaVu Sans" :char ?\➏ :size 14)
  (std::downscale "DejaVu Sans" :char ?\➐ :size 14)
  (std::downscale "DejaVu Sans" :char ?\➑ :size 14)
  (std::downscale "DejaVu Sans" :char ?\➒ :size 14)
  (std::downscale "DejaVu Sans" :char ?\➓ :size 14)
#+END_SRC

* Misc. Settings
** General Key Binds

Fill region
#+BEGIN_SRC emacs-lisp
  (std::keybind global-map
    "C-q" #'fill-region)
#+END_SRC

** Line numbers

#+BEGIN_SRC emacs-lisp
  (setq display-line-numbers-widen       t
        display-line-numbers-width-start t
        display-line-numbers-grow-only   t)
#+END_SRC

** Smooth Scrolling

No more jumpy recenter
#+BEGIN_SRC emacs-lisp
  (setq
    scroll-conservatively           20
    scroll-margin                   10
    scroll-preserve-screen-position t)
#+END_SRC

** Minor modes
*** On/Off Switches

On
#+BEGIN_SRC emacs-lisp
  (global-subword-mode t)
#+END_SRC

Off
#+BEGIN_SRC emacs-lisp
  (ido-mode -1)
  (global-hl-line-mode -1)
  (blink-cursor-mode -1)
#+END_SRC

*** Prettify Symbols

#+BEGIN_SRC emacs-lisp
  (setq-default
   prettify-symbols-alist
   `(("lambda" . "λ")
     ("!="     . "≠")
     ("<-"     . "←")
     ("->"     . "→")))
  (add-hook 'prog-mode-hook #'prettify-symbols-mode)
#+END_SRC

** Single Settings

Pos Tip colors
#+BEGIN_SRC emacs-lisp
  (std::after pos-tip
    (setq pos-tip-background-color "#2d2d2d"
          pos-tip-foreground-color "#ccb18b"))
#+END_SRC

Pack the custom settings away from the actual config to somewhere they can be easily gitignored.
#+BEGIN_SRC emacs-lisp
  (setq custom-file (std::fmt "${*SPACEMACSDIR*}/custom-file.el"))
#+END_SRC

Simple newlines
#+BEGIN_SRC emacs-lisp
  (setq next-line-add-newlines t)
#+END_SRC

No more ugly line splitting
#+BEGIN_SRC emacs-lisp
  (setq-default truncate-lines t)
#+END_SRC

I'll never want to keep my current tags when switching projects
#+BEGIN_SRC emacs-lisp
  (setq tags-add-tables nil)
#+END_SRC

Keept the fringes clean
#+BEGIN_SRC emacs-lisp
  (setq-default indicate-empty-lines nil)
#+END_SRC

Don't load outdated files
#+BEGIN_SRC emacs-lisp
  (setq load-prefer-newer t)
#+END_SRC

1 tab = 4 spaces
#+BEGIN_SRC emacs-lisp
  (setq-default tab-width 4)
#+END_SRC

No more asking to following symlinks
#+BEGIN_SRC emacs-lisp
  (setq vc-follow-symlinks t)
#+END_SRC

Dash.el highlighting
#+BEGIN_SRC emacs-lisp
  (std::after dash
     (dash-enable-font-lock))
#+END_SRC

Use firefox to open urls.
#+BEGIN_SRC emacs-lisp
  (setq browse-url-browser-function #'browse-url-firefox)
#+END_SRC

Simple title that won't cost performance.
#+BEGIN_SRC emacs-lisp
  (defun spacemacs/title-prepare (&rest __args) "" "Emacs")
#+END_SRC

Garbage collection.
#+BEGIN_SRC emacs-lisp
  (setf gc-cons-threshold 10000000
        gc-cons-percentage 0.25)
  (std::idle 2 :repeat #'garbage-collect)
#+END_SRC

** Tridactyl Start

Tridactyl cannot use ~emacsclient~, so we need a special workaround to
make sure that an emacs instance that is used as ~editorcmd~ selects the
right buffer and fixes its mode-line.

#+BEGIN_SRC emacs-lisp
  (std::idle 0.1 :no-repeat
    (when (s-starts-with? "/tmp/" (-last-item command-line-args))
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (if (s-starts-with? "tmp" (buffer-name))
              (progn 
                (switch-to-buffer buf)
                (setq-local mode-line-format (default-value 'mode-line-format)))
            (kill-buffer buf))))))
#+END_SRC

This final text prevents that the END_SRC face bleeds into the collapsed heading.
